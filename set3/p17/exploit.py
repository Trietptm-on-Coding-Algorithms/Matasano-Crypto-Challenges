from Crypto.Cipher import AES
from os import urandom
from Crypto.Util.number import getRandomRange

key = urandom(16)
iv = urandom(16)

def padding(plaintext, blocksize):
	padlen = blocksize - (len(plaintext) % blocksize)
	pt_hex = plaintext.encode("hex") + padlen*(hex(padlen)[2:].zfill(2))
	return pt_hex.decode("hex")

def CBC_encrypt(plaintext, key, iv):
	plaintext = padding(plaintext, 16)
	obj1 = AES.new(key, AES.MODE_CBC, iv)
	return obj1.encrypt(plaintext)

def PKCS7pad_validate(text):
	padbyte = text[-1]
	padlen = ord(padbyte)
	if padlen <= 0 or padlen > 16:
		raise Exception
	else:
		i = 1
		while i <= padlen:
			if text[-i] != padbyte:
				raise Exception
			i += 1

def CBC_decrypt(ciphertext, key, iv):
	obj2 = AES.new(key, AES.MODE_CBC, iv)
	plaintext = obj2.decrypt(ciphertext)
	PKCS7pad_validate(plaintext)
	return plaintext


list1 = open("strings.txt",'r').read().split("\n")
plaintext = list1[getRandomRange(0, len(list1))].decode("base64")  # Attacker doesn't have access to plaintext
print "plaintext being encrypted: ", plaintext
ciphertext = CBC_encrypt(plaintext, key, iv)
print "ciphertext is: ", ciphertext.encode("hex")

master_plaintext = ""
for i in range(16, len(ciphertext), 16):
	pt_block = "\x00"*16
	ct_prev = ciphertext[i-16:i]
	for j in range(15, -1, -1):
		custom_ctblock = "\x00"*16
		for i1 in range(15, j, -1):
			custom_ctblock = custom_ctblock[:i1] + chr((16-j) ^ ord(pt_block[i1]) ^ ord(ct_prev[i1])) + custom_ctblock[i1+1:]
		for k in range(256):
			custom_ctblock = custom_ctblock[:j] + chr(k) + custom_ctblock[j+1:]
			ct = custom_ctblock + ciphertext[i:i+16]
			try:
				CBC_decrypt(ct, key, iv)
				break
			except:
				pass
		pt_block = pt_block[:j] + chr((16-j) ^ ord(ct_prev[j]) ^ ord(custom_ctblock[j])) + pt_block[j+1:]
	master_plaintext += pt_block
print master_plaintext
